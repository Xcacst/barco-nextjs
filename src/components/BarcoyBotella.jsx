/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 .\public\Bateaupapierfinal1.glb
*/
/*
Auto-generated by: ⁦https://github.com/pmndrs/gltfjsx⁩
Command: npx gltfjsx@6.5.3 .\public\Bateaupapierfinal1.glb
*/


import React, {useEffect, useRef} from "react";
import {useFrame} from "@react-three/fiber";
import {useGLTF} from "@react-three/drei";
import * as THREE from "three";

export function Botella(props) {
	const {nodes, materials} = useGLTF("/Bateaupapierfinal1.glb");
	const bottleRef = useRef();
	
	const clipPlane = useRef(
		 new THREE.Plane(new THREE.Vector3(0, -1.5, -0.1), 0)
	);
	
	useFrame(({clock}) => {
		if (bottleRef.current) {
			const elapsedTime = clock.getElapsedTime();
			bottleRef.current.rotation.z = Math.sin(elapsedTime) * 0.1;
			bottleRef.current.rotation.x = Math.sin(elapsedTime) * 0.1;
			bottleRef.current.rotation.y = Math.sin(elapsedTime) * 0.1;
		}
	});
	
	useEffect(() => {
		if (materials.agua && props.color) {
			materials.agua.color = new THREE.Color(props.color);
		}
	}, [props.color, materials]);
	
	return (
		 <>
			 <group ref={bottleRef} dispose={true}>
				 <mesh
						geometry={nodes.botella.geometry}
						material={materials.botella}
						scale={0.6}
						onBeforeRender={(renderer, scene, camera, geometry, material) => {
							material.opacity = 0.2;
						}}
				 >
					 <mesh
							geometry={nodes.agua.geometry}
							material={materials.agua}
							position={[0, -0.08, 0.075]}
							scale={0.954}
							material-clippingPlanes={[clipPlane.current]}
							material-clipIntersection={true}
							onBeforeRender={(renderer, scene, camera, geometry, material) => {
								material.clippingPlanes = [clipPlane.current];
								material.clipIntersection = true;
								material.opacity = 0.1;
							}}
					 />
					 <mesh
							geometry={nodes.boichon.geometry}
							material={materials["color bouchon"]}
							position={[0, -0.096, -2.388]}
							rotation={[0.006, 0, 0]}
							scale={0.255}
							onUpdate={(self) => self.material.color.set("#5f5350")}
					 />
				 </mesh>
			 </group>
		 </>
	);
}

export function Barco(props) {
	const {nodes, materials} = useGLTF("/Bateaupapierfinal1.glb");
	const boatRef = useRef(null);
	
	useEffect(() => {
		if (materials["barco papel"] && props.color) {
			materials["barco papel"].color = new THREE.Color(props.color);
		}
	}, [props.color, materials]);
	
	useEffect(() => {
		if (boatRef.current) {
			boatRef.current.scale.set(0, 0, 0); // Définir la scale initiale à 0
		}
	}, []);
	
	useFrame(({clock}) => {
		if (boatRef.current) {
			const elapsedTime = clock.getElapsedTime();
			boatRef.current.rotation.z = Math.sin(elapsedTime) * -0.05;
			boatRef.current.rotation.x = Math.sin(elapsedTime) * -0.05;
			boatRef.current.rotation.y = Math.sin(elapsedTime) * -0.1;
		}
	});
	
	useFrame(() => {
		if (boatRef.current) {
			const targetScale = props.isVisible ? -0.1 : 0;
			boatRef.current.scale.x = THREE.MathUtils.lerp(boatRef.current.scale.x, targetScale, 0.1);
			boatRef.current.scale.y = THREE.MathUtils.lerp(boatRef.current.scale.y, targetScale, 0.1);
			boatRef.current.scale.z = THREE.MathUtils.lerp(boatRef.current.scale.z, targetScale, 0.1);
		}
	});
	
	return (
		 <group {...props} ref={boatRef} dispose={null}>
			 <mesh
					geometry={nodes.barco.geometry}
					material={materials["barco papel"]}
					position={[0, -0.05, -0.05]}
					rotation={[0, 0, 0]}
					//scale={-0.1}
			 />
		 </group>
	);
}

useGLTF.preload("/Bateaupapierfinal1.glb");
